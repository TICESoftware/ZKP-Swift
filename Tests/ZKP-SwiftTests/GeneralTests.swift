import CryptoKit
import Digest
import SwiftECC
import XCTest
@testable import ZKP_Swift

let privateKeyPEM = """
-----BEGIN PRIVATE KEY-----
MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgb4UzEf6QFxSVF9yz
TA3+WFFacPJfp2iXgd+A2ZEzPJqhRANCAASwW742XU1e8LxEz8heJcu7wxUDtfuZ
dPcme9vm4fEr/klnGLTCrMZDXUqNm9QXwW1z+gYDNZ0+ZPAYSDlkPb3e
-----END PRIVATE KEY-----
"""

let publicKeyPEM = """
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsFu+Nl1NXvC8RM/IXiXLu8MVA7X7
mXT3Jnvb5uHxK/5JZxi0wqzGQ11KjZvUF8Ftc/oGAzWdPmTwGEg5ZD293g==
-----END PUBLIC KEY-----
"""

let ephPublicKeyPEM = """
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAETh2gvUk5JJmz+381XiN6gVZrAu4R
cqKw0CDsXMccimgga3wvNwjaMTFE34NFROJurbCOEtna6gSMFwQQk5Gt6Q==
-----END PUBLIC KEY-----
"""

let ephPrivateKeyPEM = """
-----BEGIN PRIVATE KEY-----
MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgandHRq1kbZypYtUN
CbiSWKbtgDpb44KNGEhyAU/FbVKgCgYIKoZIzj0DAQehRANCAAROHaC9STkkmbP7
fzVeI3qBVmsC7hFyorDQIOxcxxyKaCBrfC83CNoxMUTfg0VE4m6tsI4S2drqBIwX
BBCTka3p
-----END PRIVATE KEY-----
"""

let challengePublicKeyPEM = """
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE1yu+OWNhRwFODLm/loVSpUdRZC2C
2aiB1+Et7Y300OsId7Mq9Z3ecplLGRaFAoPCkPylDysY0Hqp2VerlX7wgA==
-----END PUBLIC KEY-----
"""

let challengePrivateKeyPEM = """
-----BEGIN PRIVATE KEY-----
MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCBKcjFocoaViPkin2Tm
5XPAXPR5zYG7rA7px6i0CJ1ICA==
-----END PRIVATE KEY-----
"""

final class GeneralTests: XCTestCase {
    func testWholeFlow() throws {
        let issuerPublicKey = try ECPublicKey(pem: publicKeyPEM)
        let prover = ZKPProver(issuerPublicKey: issuerPublicKey)
        let verifier = ZKPVerifier(issuerPublicKey: issuerPublicKey)

        let someJwt = "eyJhbGciOiJFUzI1NiJ9.U29tZSByYXcgbWVzc2FnZQ.Zh2GRwhm36gpV1TZc_j5E74P4taykE0CxKICGPxVP-bsP1BQIKKixBJe6CQpAt0dizITTHQnLujDNFAMixcT-w"
        let request = try prover.createChallengeRequest(vpTokenFormat: .sdJWT, data: someJwt)

        let (challengePublicKey, challengePrivateKey) = try verifier.createChallenge(requestData: request)

        let answer = try prover.answerChallenge(ephemeralPublicKey: challengePublicKey, vpTokenFormat: .sdJWT, data: someJwt)

        let result = try verifier.verifyChallenge(vpTokenFormat: .sdJWT, data: answer, key: challengePrivateKey)

        XCTAssertTrue(result)
    }

    func testDeterministicSignature() throws {
        let issuerPrivateKey = try ECPrivateKey(pem: privateKeyPEM)
        let issuerPublicKey = try ECPublicKey(pem: publicKeyPEM)
        let prover = ZKPProver(issuerPublicKey: issuerPublicKey)

        let ephPubKey = try ECPublicKey(pem: ephPublicKeyPEM)

        let payloadData = Data("Some raw string".utf8)
        let sha256 = SHA256.hash(data: payloadData)
        let sha256Bytes = Bytes(sha256)
        let encoded = Base64.encode(sha256Bytes)
        print(encoded)

        let signature = issuerPrivateKey.sign(msg: sha256Bytes, deterministic: true)
        let signatureBase64UrlEncoded = Base64.encode(signature.r + signature.s, -1)
        print(signatureBase64UrlEncoded)

        let (R, S) = try prover.answerChallenge(ephemeralPublicKey: ephPubKey, digest: sha256Bytes, signatureR: signature.r, signatureS: signature.s)
        let base64EncodedSignature = Base64.encode(R + S, -1)

        XCTAssertEqual(base64EncodedSignature, "Am1Q+qb0kPPSZu8SyY44FK0EgBcFMPb0C6LCsIl6qjSbA45/2zadsTAEl8HDWIJWMK+EJNyV95/YL9V2rXuGj4y1")
    }

    func testKotlinSignature() throws {
        let issuerPublicKey = try ECPublicKey(pem: publicKeyPEM)

        let payloadData = Data("Some raw string".utf8)
        let payloadDigest = Bytes(SHA256.hash(data: payloadData))

        // The signature was generated by kotlin
        let signatureBase64URLEncoded = "v2eKEsw0rlxHIY1uUzXWkVB-WSnhcMTujqZmDeRAkURZqkWnUM4D1ixhzYn1pA7OSiP3FBxNIlv7I5TU0fce0g"
        let signatureData = Data(base64URLEncoded: signatureBase64URLEncoded)!
        let bytes = Bytes(signatureData)
        let r = Bytes(bytes[0 ..< bytes.count / 2])
        let s = Bytes(bytes[bytes.count / 2 ..< bytes.count])
        let domain = issuerPublicKey.domain
        let signature = ECSignature(domain: domain, r: r, s: s)

        XCTAssertTrue(issuerPublicKey.verify(signature: signature, msg: payloadDigest, bw: nil))
    }

    func testAnswerChallengeFromKotlin() throws {
        let issuerPublicKey = try ECPublicKey(pem: publicKeyPEM)
        let prover = ZKPProver(issuerPublicKey: issuerPublicKey)

        let ephPubKey = try ECPublicKey(pem: challengePublicKeyPEM)
        let jwtFromKotlin = "eyJhbGciOiJFUzI1NiJ9.U29tZSByYXcgbWVzc2FnZQ.Zh2GRwhm36gpV1TZc_j5E74P4taykE0CxKICGPxVP-bsP1BQIKKixBJe6CQpAt0dizITTHQnLujDNFAMixcT-w"
        let zkpJwt = try prover.answerChallenge(ephemeralPublicKey: ephPubKey, vpTokenFormat: .sdJWT, data: jwtFromKotlin)

        let jwtParts = jwtFromKotlin.split(separator: ".")
        let zkpJwtParts = zkpJwt.split(separator: ".")

        XCTAssertEqual(jwtParts[0], zkpJwtParts[0])
        XCTAssertEqual(jwtParts[1], zkpJwtParts[1])
        XCTAssertNotEqual(jwtParts[2], zkpJwtParts[2])

        // There is a test on kotlin side that verifies that this answer is a valid zkp proof
        XCTAssertEqual(zkpJwtParts[2], "AjeYqOQOhFykHYcZaZ2Xa-M7CjM1XVXFYZ9pPXQBWdLvA5xBdYSr9aI_8ak0cosZj5qW-Bc4RUeeVN7BqUoggzJ5")
    }

    func testCreateChallengeRequestSDJWT() throws {
        let issuerPublicKey = try ECPublicKey(pem: publicKeyPEM)
        let prover = ZKPProver(issuerPublicKey: issuerPublicKey)

        let jwt = "eyJhbGciOiJFUzI1NiJ9.U29tZSByYXcgbWVzc2FnZQ.Zh2GRwhm36gpV1TZc_j5E74P4taykE0CxKICGPxVP-bsP1BQIKKixBJe6CQpAt0dizITTHQnLujDNFAMixcT-w"
        let challengeRequestData = try prover.createChallengeRequest(vpTokenFormat: .sdJWT, data: jwt)

        XCTAssertEqual(challengeRequestData.digest, "nLT2lz465dAnKWRSfjsImppvJ4gun1Rzy2_RPYH4fec")
        XCTAssertEqual(challengeRequestData.r, "Zh2GRwhm36gpV1TZc_j5E74P4taykE0CxKICGPxVP-Y")
    }

    func testGenerateKey() throws {
        let domain = Domain.instance(curve: .EC256r1)
        let (pub, pri) = domain.makeKeyPair()
        print(pub.pem)
        print(pri.pemPkcs8)
    }
}
